# MetaNode 质押平台文档

## 概述

MetaNode 质押平台是一个去中心化的质押系统，允许用户质押 ETH 和 ERC20 代币来获得 MetaNodeStake 代币奖励。平台支持多池质押、灵活的奖励分配机制和完善的风险控制。

## 核心功能

### 1. 质押功能
- **多币种支持**: 支持 ETH 和各种 ERC20 代币质押
- **多池机制**: 支持创建多个质押池，每个池有独立的权重和奖励
- **灵活存款**: 支持多次存款，自动累积质押金额
- **最小存款限制**: 设置最小存款金额防止粉尘攻击

### 2. 解除质押功能
- **锁定期机制**: 解除质押后需要等待锁定期才能提取
- **分离设计**: 解除质押和提取是两个独立操作
- **余额保护**: 防止提取超过可用余额
- **时间验证**: 确保锁定期结束后才能提取

### 3. 奖励系统
- **区块奖励**: 基于区块高度计算奖励
- **池权重**: 不同池有不同的奖励权重
- **按比例分配**: 用户奖励按质押比例分配
- **实时计算**: 支持实时查询和领取奖励

## 智能合约架构

### 合约文件
- `MetaNodeStake.sol` - 主质押合约，处理质押、解除质押和奖励分配
- `MetaNode.sol` - MetaNode 代币合约

### 关键数据结构

#### Pool 结构体
```solidity
struct Pool {
    address token;           // 质押代币地址 (address(0) 表示 ETH)
    uint256 allocPoint;      // 分配点数，决定池权重
    uint256 lastRewardBlock; // 上次奖励计算的区块
    uint256 accMetaNodePerShare; // 累积每股奖励
    uint256 totalStaked;     // 池中总质押量
    uint256 minDeposit;      // 最小存款金额
}
```

#### UserInfo 结构体
```solidity
struct UserInfo {
    uint256 amount;          // 用户质押数量
    uint256 rewardDebt;      // 奖励债务
    uint256 pendingWithdraw; // 待提取金额
    uint256 withdrawTime;    // 可提取时间
}
```

### 核心特性
- **可升级性**: 使用 OpenZeppelin 可升级合约模式
- **安全性**: 集成重入保护、暂停机制和权限控制
- **精确计算**: 使用高精度数学运算确保奖励计算准确
- **事件日志**: 完整的事件记录便于监控和审计

## 部署指南

### 部署脚本
- `05_deploy_MetaNodeStake.js` - 部署质押合约和代币合约

### 部署命令
```bash
# 测试网部署
npx hardhat deploy --network sepolia --tags MetaNodeStakeDeploy
```

### 部署参数
- `startBlock`: 奖励开始区块
- `endBlock`: 奖励结束区块
- `MetaNodePerBlock`: 每个区块的奖励数量
- `MetaNodeTokenAddress`: MetaNode 代币合约地址

## 测试指南

### 测试文件
- 测试文件路径: `test/MetaNodeStake/MetaNodeStake.t.sol`
- 测试框架: Foundry

### 运行测试
```bash
# 运行所有测试
forge test

# 运行特定测试
forge test --match-test testRewardCalculationPrecision

# 详细输出
forge test -vv
```

### 测试内容

#### 基础功能测试
- **合约初始化**: 验证合约正确初始化和参数设置
- **重复初始化防护**: 确保合约不能被重复初始化
- **池管理**: 测试添加池、设置权重、重复池检查
- **权限控制**: 验证仅管理员可执行敏感操作

#### 质押功能测试
- **ERC20 代币质押**: 测试各种 ERC20 代币的质押功能
- **ETH 质押**: 验证原生 ETH 质押机制
- **最小存款金额验证**: 确保低于最小金额的存款被拒绝
- **多次存款累积**: 测试用户多次存款的正确累积

#### 解除质押功能测试
- **解除质押请求**: 验证解除质押请求的正确处理
- **锁定期机制**: 确保锁定期内无法提取资金
- **提取功能**: 测试 ERC20 和 ETH 的提取功能
- **余额不足保护**: 验证提取金额超过余额时的错误处理
- **提前提取保护**: 确保锁定期内提取被正确拒绝

#### 奖励系统测试
- **单用户奖励计算**: 验证单用户在固定区块数下的精确奖励计算
- **多用户奖励分配**: 测试多用户按质押比例分配奖励
- **奖励精确性验证**: 确保奖励计算的数学准确性
- **池权重对奖励分配的影响**: 验证不同权重池的奖励差异
- **奖励时间累积测试**: 测试奖励在不同时间段的正确累积
- **边界条件**: 验证开始/结束区块边界的奖励计算

#### 安全性测试
- **暂停/恢复功能**: 测试合约暂停状态下的功能限制
- **重入攻击防护**: 验证重入保护机制的有效性
- **溢出保护**: 测试大数值计算的安全性
- **无效参数处理**: 确保无效输入被正确拒绝

#### 复杂场景测试
- **多池多用户综合测试**: 模拟真实环境的复杂交互
- **参数设置和权限验证**: 测试各种参数设置的权限控制
- **边界条件处理**: 验证极端情况下的合约行为

### 测试覆盖率
测试覆盖了质押奖励计算的精确性、多用户按比例分配、池权重影响等关键业务逻辑，确保合约在各种场景下的正确性和安全性。

## API 参考

### 管理员方法
- `addPool(allocPoint, token, minDeposit, withUpdate)` - 添加新的质押池
- `setPool(pid, allocPoint, withUpdate)` - 设置池权重
- `setMetaNodePerBlock(MetaNodePerBlock)` - 设置每区块奖励
- `setWithdrawLockTime(withdrawLockTime)` - 设置提取锁定时间
- `pause()` / `unpause()` - 暂停/恢复合约

### 用户方法
- `deposit(pid, amount)` - 存款质押
- `withdraw(pid, amount)` - 解除质押
- `claim(pid, amount)` - 提取资金
- `harvest(pid)` - 领取奖励
- `pendingMetaNode(pid, user)` - 查询待领取奖励
- `getUserInfo(pid, user)` - 获取用户信息

### 查询方法
- `poolLength()` - 获取池数量
- `getPoolInfo(pid)` - 获取池信息
- `totalAllocPoint()` - 获取总分配点数
- `getMultiplier(from, to)` - 计算区块倍数

## 经济模型

### 奖励计算公式
```
池奖励 = (当前区块 - 上次奖励区块) × 每区块奖励 × 池权重 / 总权重
用户奖励 = 池奖励 × 用户质押量 / 池总质押量
```

### 关键参数
- **MetaNodePerBlock**: 每个区块产生的奖励代币数量
- **allocPoint**: 池的分配权重，决定该池获得的奖励比例
- **withdrawLockTime**: 解除质押后的锁定时间
- **minDeposit**: 每个池的最小存款金额

## 安全考虑

### 风险控制
1. **重入攻击防护**: 使用 ReentrancyGuard 防止重入攻击
2. **整数溢出保护**: 使用 SafeMath 或 Solidity 0.8+ 内置保护
3. **权限控制**: 关键操作仅限管理员执行
4. **暂停机制**: 紧急情况下可暂停合约操作
5. **时间锁**: 解除质押后设置锁定期

### 审计建议
1. **数学计算**: 重点审计奖励计算逻辑的准确性
2. **状态管理**: 检查用户状态和池状态的一致性
3. **边界条件**: 测试极端值和边界情况
4. **权限验证**: 确保权限控制的完整性

## 故障排除

### 常见问题
1. **奖励计算错误**: 检查区块高度和池权重设置
2. **提取失败**: 验证锁定期是否结束
3. **权限错误**: 确认调用者是否有相应权限
4. **余额不足**: 检查合约和用户余额

### 调试建议
- 使用事件日志跟踪状态变化
- 检查池信息和用户信息的一致性
- 验证时间戳和区块高度
- 确认代币授权和余额